/* This game has been re-worked so that puzzle images are JPGs (as opposed to SWFs). To use, simply link to a jpg of an appropriate size. The program slices the image into squares based on the height of the image. So, for example, if the image is 120px high, it slices it into as many 120px x 120px images as it can int(width / height). Images should be place next to each other horizontally, like a set of slides. */package com.borch {	import com.greensock.*;	import com.greensock.easing.*;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;	import org.casalib.layout.Distribution;	public class MemoryGame extends MovieClip implements IGame {		private const OPTIONS:Array = [4, 8];		private var imageSize:int;		private const LAYOUT_SIZE:int = 400;		private var Image:Bitmap;		private var setSize:int;		private var Layout:Distribution;		private var Card:MovieClip;		private var CardSet:Array = [];		private var CardOne:MovieClip;		private var CardTwo:MovieClip;		public function MemoryGame () {			super ();		}		public function initGame (resource:Object = null):void {			resource.visible = false;			Image = Bitmap (resource);			imageSize = Image.height;			if ((Image.width / imageSize) < 8) {				trace ('Image not long enough--not enough image squares (must be at least 8)');				return;			}			Layout = new Distribution;			addChild (Layout);			Layout.size = LAYOUT_SIZE;			Layout.x = 200;			Layout.y = 20;			Layout.setMargin (0, 8, 8, 0);			/*			 var Icon:Bitmap = addChild (new Bitmap (Image.bitmapData.clone()));			 Icon.filters = [new DropShadowFilter (4, 45, 0, 1, 16, 16)];			 Center.it (Icon, iconTarget);			 */		}		public function resetGame (option:Object = null):void {			if (!setSize) setSize = OPTIONS [option];			Layout.addEventListener (MouseEvent.MOUSE_DOWN, firstTime, false, 0, true);			CardOne = CardTwo = null;			makeCardLayout ();			stopGame ();			TweenMax.fromTo (Layout, 2, { scaleX : .2, scaleY : .2}, { scaleX : 1, scaleY : 1, ease : Elastic.easeOut, onComplete : startGame, onCompleteParams : [true] });		}		private function firstTime (e:MouseEvent):void {			e.target.removeEventListener (MouseEvent.MOUSE_DOWN, firstTime);			GameManager.instance.gameStarted ();		}		public function startGame (firstTime:Boolean = false):void {			for each (Card in CardSet) Card.addEventListener (MouseEvent.MOUSE_UP, clickCard, false, 0, true);		}		public function stopGame (gameOver:Object = false):void {			for each (Card in CardSet) Card.removeEventListener (MouseEvent.MOUSE_UP, clickCard);			if (gameOver) GameManager.instance.gameFeedback ();		}		public function cleanUp ():void {			stopGame ();			TweenMax.killAll ();		}		// ********* END IGame FUNCTIONS *********		// ********* START GAME FUNCTIONS *********		private function makeCardLayout ():void {			// MAKE SET OF RANDOM KEYS AND DUPLICATE			var randSet:Array = Util.randArray (int (Image.width / imageSize)).splice (0, setSize);			randSet = randSet.concat (randSet.slice ());			Util.randArray (randSet);			while (Layout.numChildren) Layout.removeAllChildren (true);			var bmdRect:Rectangle = new Rectangle (0, 0, imageSize, imageSize);			var bmdPoint:Point = new Point (0, 0);			while (randSet.length) {				var cardKey:int = randSet.pop ();				bmdRect.x = int (imageSize * cardKey);				NewCard = new CardClip;				NewCard.Back = NewCard.getChildAt (0);				var NewBMD:BitmapData = new BitmapData (imageSize, imageSize, false, 0);				NewBMD.copyPixels (Image.bitmapData, bmdRect, bmdPoint);				NewCard.Front = NewCard.addChild (new Bitmap (NewBMD));				Center.it (NewCard.Front, NewCard.Back, 1);				NewCard.useHandCursor = NewCard.buttonMode = true;				NewCard.Front.visible = false;				NewCard.key = cardKey;				CardSet.push (NewCard);				Layout.addChild (NewCard);			}			Layout.position ();			var layoutHalfWidth:int = int (Layout.width / 2);			var layoutHalfHeight:int = int (Layout.height / 2);			for each (Card in CardSet) {				Card.x -= layoutHalfWidth;				Card.y -= layoutHalfHeight;			}			Center.it (Layout, stage, 0, 120, -30);		}		private function clickCard (event:MouseEvent):void {			var ClickOn:MovieClip = MovieClip (event.currentTarget);			if (CardOne == ClickOn) return; // IGNORE IF CLICK TWICE ON SAME CARD			flipCard (ClickOn); // FLIP CARD			if (!CardOne) {// NO CARDS UP				CardOne = ClickOn;				return;			}			if (!CardTwo) {// ONE CARD UP				CardTwo = ClickOn;				if (CardOne.key != CardTwo.key) {// NO MATCH					TweenMax.delayedCall (2, resetCards);				} else {// MATCH!					removeCard (CardOne);					removeCard (CardTwo);					if (!CardSet.length) stopGame (true);				}			} else {// TWO CARDS UP, RESET THEM				TweenMax.killDelayedCallsTo (resetCards);				resetCards ();				CardOne = ClickOn;			}		}		private function resetCards ():void {			flipCard (CardOne);			flipCard (CardTwo);			CardOne = CardTwo = null;		}		// SPIN/REMOVE CARD		private function removeCard (Card:MovieClip):void {			Util.asButton (Card, false, 1);			CardSet.splice (CardSet.indexOf (Card), 1);			Card.removeEventListener (MouseEvent.MOUSE_UP, clickCard);			Util.bringFront (Card);			TweenMax.to (Card, 1.5, { delay : .7, rotation : 720, autoAlpha : 0, scaleX : 3, scaleY : 3 });			Card = null;		}		private static function flipCard (Card:MovieClip):void {			TweenMax.to (Card, .3, { scaleX : 0, ease : Cubic.easeIn, onComplete : flipAgain });			function flipAgain ():void {				Card.Front.visible = !Card.Front.visible;				Card.Back.visible = !Card.Back.visible;				TweenMax.to (Card, .3, { scaleX : 1, ease : Cubic.easeOut });			}		}	}}