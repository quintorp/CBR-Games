package com.borch {	import com.greensock.TweenMax;	import flash.display.MovieClip;	import flash.events.AccelerometerEvent;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.geom.ColorTransform;	import flash.geom.Point;	import flash.sensors.Accelerometer;	public class Fisherman extends MovieClip {		private const KEYS_OK:Object = { 37 : 'left', 38 : 'up', 39 : 'right', 40 : 'down', 32 : 'jump', 16 : 'duck' };		private var keysDown:Object = {};		private var hor:int = 0;		private var ver:int = 0;		private var sinking:Boolean = false;		private static const LIMIT_LEFT:int = 90;		private static var limit_right:int = 710;		private static const LIMIT_TOP:int = 0;		private static var limit_bottom:int = 550;		private static var startPoint:Point;		private static const VER_STEP_SIZE:Number = 20;		private static const HOR_STEP_SIZE:Number = 10;		private var accel:Accelerometer;		public function Fisherman () {			super ();			stop ();			scaleX = scaleY = .4;			addEventListener (Event.ADDED_TO_STAGE, init, false, 0, true);		}		public function init (e:Event = null):void {			removeEventListener (Event.ADDED_TO_STAGE, init);			addEventListener (Event.REMOVED_FROM_STAGE, stopActor, false, 0, true);			Center.it (this, stage, 0, 0, -70);			limit_right = stage.stageWidth - LIMIT_LEFT;			limit_bottom = Net.height - 260;			startPoint = new Point (x, y);			resetActor ();		}		private function tiltEvent (accelEvent:AccelerometerEvent):void {			hor = (Math.abs (accelEvent.accelerationX) < .2) ? 0 : 1 - 2 * int (accelEvent.accelerationX > 0);			ver = (Math.abs (accelEvent.accelerationY) < .2) ? 0 : 1 - 2 * int (accelEvent.accelerationY < 0);		}		private function update (e:Event = null):void {			if ((hor == -1) && ((x - HOR_STEP_SIZE) > LIMIT_LEFT))   x -= HOR_STEP_SIZE;			if ((hor == +1) && ((x + HOR_STEP_SIZE) < limit_right))  x += HOR_STEP_SIZE;			if ((ver == -1) && ((Net.y - VER_STEP_SIZE) > LIMIT_TOP))    Net.y -= VER_STEP_SIZE;			if ((ver == +1) && ((Net.y + VER_STEP_SIZE) < limit_bottom)) Net.y += VER_STEP_SIZE;		}		public function startActor (event:Event = null):void {			if (Accelerometer.isSupported) {				accel = new Accelerometer ();				accel.setRequestedUpdateInterval (100);				accel.addEventListener (AccelerometerEvent.UPDATE, tiltEvent, false, 0, true);			}			addEventListener (Event.ENTER_FRAME, update, false, 0, true);			stage.addEventListener (KeyboardEvent.KEY_DOWN, keyboardEvent, false, 0, true);			stage.addEventListener (KeyboardEvent.KEY_UP, keyboardEvent, false, 0, true);		}		public function stopActor (event:Event = null):void {			hor = ver = 0;			gotoAndStop ('standing');			if (accel) accel.removeEventListener (AccelerometerEvent.UPDATE, tiltEvent);			removeEventListener (Event.ENTER_FRAME, update);			stage.removeEventListener (KeyboardEvent.KEY_DOWN, keyboardEvent);			stage.removeEventListener (KeyboardEvent.KEY_UP, keyboardEvent);		}		private function keyboardEvent (k:KeyboardEvent):void {			if (k.type == 'keyDown') {				if ((k.keyCode in keysDown) || (!(k.keyCode in KEYS_OK))) return;				keysDown [k.keyCode] = true;			} else {				delete keysDown [k.keyCode];			}			switch (k.keyCode) {				case 37 :					hor = (k.type == 'keyDown') ? -1 : 0;					break;				case 38 :					ver = (k.type == 'keyDown') ? -1 : 0;					break;				case 39 :					hor = (k.type == 'keyDown') ? 1 : 0;					break;				case 40 :					ver = (k.type == 'keyDown') ? 1 : 0;					break;			}			Boolean (ver) ? gotoAndStop ('fishing') : gotoAndStop ('standing');		}		// FISH CAUGHT, LOWER BOAT & MAKE RED, SINK IF TOO MANY!		public function caughtFish ():int {			if (sinking) return 0;//			Too many fish in boat, sink it!			if (Net.currentFrame == Net.totalFrames) {				sinking = true;				stopActor ();				TweenMax.killTweensOf (this);				TweenMax.to (this, 5, { y : stage.stageHeight, onComplete : resetActor });				return 1;			}//			BOAT ALMOST FULL, FLASH BOAT RED!			if (Net.currentFrame == Net.totalFrames - 1) {				TweenMax.to (Rock, .5, { colorTransform : {tint : 0xFF0000, tintAmount : 0.8}, yoyo : true, repeat : -1 });			}			Net.nextFrame ();			// ADJUST DEPTH BASED ON FISH CAUGHT			y += 3;			var boatColor:ColorTransform = Rock.transform.colorTransform;			boatColor.redOffset += 25;			Rock.transform.colorTransform = boatColor;			return 2;		}//		IF HAS FISH, DROP OFF CAUGHT FISH & RESET		public function dropOffFish ():Boolean {			var hasFish:Boolean = Net.currentFrame > 1;			if (hasFish) resetActor (false);			return hasFish;		}//		RESET ACTOR TO ORIGINAL POSITION		public function resetActor (center:Boolean = true):void {			TweenMax.killTweensOf (Rock);			sinking = false;			Net.gotoAndStop (1);			Net.y = 0;			y = startPoint.y;			if (center) x = startPoint.x;			Rock.transform.colorTransform = new ColorTransform ();		}	}}