package com.borch {	import com.greensock.*;	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.text.TextFormat;	import org.casalib.util.GeomUtil;	public class FinderGame extends MovieClip implements IGame {		private var gameXML:XML;		private var extraLetters:String;		private var Letters:Array;		private var Letter:MovieClip;		private var FoundLoops:Array = [];		private var Loop:MovieClip;		private var Puzzle:MovieClip = new MovieClip;		private var Field:MovieClip;		public function FinderGame () {			super ();		}		public function initGame (resource:Object = null):void {			XML.ignoreWhitespace = false;			gameXML = new XML (resource);			makeGameField ();			// ADD WORDS TO CLUE FIELD, ADD SCROLLBAR, UPDATE			addChild (Puzzle);			Puzzle.addChild (ClueField);			var ClueScroller:ScrollBar = addChild (new ScrollBar (ClueField));			var clueText:String = extraLetters = '';			for each (var entry:XML in gameXML.entry) {				extraLetters += entry.@word;				clueText += entry.@word + '\n';				entry.@loc = entry.@start + '+' + entry.@end;			}			ClueScroller.update (clueText);		}		public function resetGame (option:Object = null):void {			if (option != null) extraLetters = (option) ? extraLetters : null;			if (!Field) makeGameField ();			ClueField.setTextFormat (new TextFormat (null, null, 0x000088));			for each (Loop in FoundLoops) Destroy.it (Loop);			for each (Letter in Letters) Letter.visible = true;			for each (var entry:XML in gameXML.entry) entry.@found = 0;			Field.addEventListener (MouseEvent.MOUSE_DOWN, firstTime, false, 0, true);			stopGame ();			startGame (true);		}		private function firstTime (e:MouseEvent):void {			Field.removeEventListener (MouseEvent.MOUSE_DOWN, firstTime);			GameManager.instance.gameStarted ();		}		public function startGame (firstTime:Boolean = false):void {			for each (Letter in Letters) {				Letter.addEventListener (MouseEvent.MOUSE_DOWN, setLoopStart, false, 0, true);				Letter.useHandCursor = Letter.buttonMode = true;			}		}		public function stopGame (gameOver:Object = false):void {			for each (Letter in Letters) {				Letter.removeEventListener (MouseEvent.MOUSE_DOWN, setLoopStart);				Letter.useHandCursor = Letter.buttonMode = false;			}			Field.removeEventListener (MouseEvent.MOUSE_UP, checkLoopForWord);			stage.removeEventListener (MouseEvent.MOUSE_UP, checkLoopForWord);			stage.removeEventListener (MouseEvent.MOUSE_MOVE, setLoopEnd);			if (gameOver) {				GameManager.instance.gameFeedback ();				colorLoops ();			}		}		private function colorLoops ():void {			for (var i:int in Letters) Letters [i].visible = gameXML.grid.charAt (i) != ' ';			for each (Loop in FoundLoops) {				Loop.alpha = 1;				Loop.cDrag.Bg.visible = true;				Util.cycleColor (Loop.cDrag.Bg);			}		}		public function cleanUp ():void {			stopGame ();			TweenMax.killAll ();		}		public function solveGame ():void {			stopGame ();			for each (var entry:XML in gameXML.entry) {				if (entry.@found == 1) continue;				// ADD LOOP				var NewLoop:CircleMarker = new CircleMarker ();				Field.addChildAt (NewLoop, 0);				var begLetter:MovieClip = Letters[entry.@start];				var endLetter:MovieClip = Letters[entry.@end];				NewLoop.x = begLetter.x;				NewLoop.y = begLetter.y;				NewLoop.rotation = GeomUtil.angle (new Point (begLetter.x, begLetter.y), new Point (endLetter.x, endLetter.y));				NewLoop.cDrag.x = Math.sqrt (Math.pow ((begLetter.x - endLetter.x), 2) + Math.pow ((begLetter.y - endLetter.y), 2));				FoundLoops.push (NewLoop);			}			colorLoops ();		}		// ********* END IGame FUNCTIONS *********		// ********* START GAME FUNCTIONS *********		// Add a Loop and place it over the Letter movieclip user clicks on.		private function setLoopStart (event:MouseEvent):void {			Loop = new CircleMarker;			Field.addChildAt (Loop, 0);			Loop.x = event.currentTarget.x;			Loop.y = event.currentTarget.y;			Loop.begPoint = new Point (Loop.x, Loop.y);			Loop.begIndex = Letters.indexOf (event.currentTarget);			Loop.endIndex = NaN;			Loop.cDrag.Bg.visible = false;			Field.addEventListener (MouseEvent.MOUSE_UP, checkLoopForWord, false, 0, true);			stage.addEventListener (MouseEvent.MOUSE_UP, checkLoopForWord, false, 0, true);			stage.addEventListener (MouseEvent.MOUSE_MOVE, setLoopEnd, false, 0, true);		}		// Move the Loop over letters if in line.		private function setLoopEnd (event:MouseEvent):void {			var EndLetter:MovieClip;			Loop.endIndex = NaN;			for each (Letter in Letters) if (Letter.hitTestPoint (mouseX, mouseY)) EndLetter = Letter;			if (!EndLetter) return; // NOT OVER A LETTER			var endPoint:Point = new Point (EndLetter.x, EndLetter.y);			var angle:Number = GeomUtil.angle (Loop.begPoint, endPoint);			// Clip is in line if angle is a multiple of 45°.			if (angle % 45) return;			Loop.rotation = angle;			Loop.cDrag.x = Math.sqrt (Math.pow ((endPoint.x - Loop.begPoint.x), 2) + Math.pow ((endPoint.y - Loop.begPoint.y), 2));			Loop.endPoint = endPoint;			Loop.endIndex = Letters.indexOf (EndLetter);		}		// Check if Loop circles word when user releases mouse over Letter.		private function checkLoopForWord (e:MouseEvent):void {			stage.removeEventListener (MouseEvent.MOUSE_MOVE, setLoopEnd);			Field.removeEventListener (MouseEvent.MOUSE_UP, checkLoopForWord);			stage.removeEventListener (MouseEvent.MOUSE_UP, checkLoopForWord);			var foundWord:XMLList = gameXML.entry.(@loc == (Loop.begIndex + '+' + Loop.endIndex));			if (foundWord.@found != 0) foundWord = gameXML.entry.(@loc == (Loop.endIndex + '+' + Loop.begIndex));			if (foundWord.@found == 0) { // IT'S A MATCH!				var theWord:String = foundWord.@word;				var wordStart:int = ClueField.text.indexOf (theWord);				var foundFormat:TextFormat = new TextFormat (null, null, 0xAAAAAA);				ClueField.setTextFormat (foundFormat, wordStart, wordStart + theWord.length);				Loop.alpha = .2;				Loop.cDrag.Bg.visible = true;				foundWord.@found = 1;				FoundLoops.push (Loop);				Loop = null;			} else {				Destroy.it (Loop);			}			if (!gameXML.entry.(attribute ('found') == 0).length()) stopGame (true);		}		private function makeGameField ():void {			Field = new MovieClip;			Puzzle.addChild (Field);			// DUMMY CLIP TO GET DIMENSIONS			var dummy:MovieClip = new FinderLtrClip ();			var letterWidth:Number = dummy.width;			var letterHeight:Number = dummy.height;			var gridString:String = Util.fillInBlanks (gameXML.grid, extraLetters);			var rows:int;			var cols:int;			// Calc grid rows and columns (assumed to be square).			rows = cols = Math.round (Math.sqrt (gridString.length));			Letters = [];			for (var i:int = 0; i < gridString.length; i++) {				var NewLetter:MovieClip = new FinderLtrClip ();				Field.addChild (NewLetter);				Letters.push (NewLetter);				NewLetter.LetterClip.text = gridString.charAt (i);				NewLetter.mouseChildren = false;				NewLetter.x = (i % cols) * letterWidth;				NewLetter.y = Math.floor (i / rows) * letterHeight;			}			Center.it (Field, PuzRect, 1);			Util.bringFront (Field);		}		public function get Printable ():MovieClip {			return Puzzle;		}	}}