package com.borch {	import com.greensock.*;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.events.Event;	import flash.geom.Matrix;	public class MatchGame extends MovieClip implements IGame {		private var PicHolder:MovieClip;     // CLIP TO HOLD IMAGE		private var ButtonsClip:MovieClip;   // CLIP TO HOLD BUTTONS		private var ButtonsAll:Array = [];   // ARRAY TO HOLD ALL BUTTONS		private var ButtonsActive:Array = [];// ARRAY TO HOLD ACTIVE BUTTONS		private var ImagesAll:Array = [];    // ARRAY TO HOLD ALL IMAGES		private var ImagesCopy:Array = [];   // ARRAY TO HOLD COPY OF IMAGES		private var Btn:MovieClip;		private var ind:int;		private var score:int;		private var pixelSize:Number;		public function MatchGame () {			super ();		}		public function initGame (resource:Object = null):void {			addEventListener ('buttonClick', buttonClick, false, 0, true);			PicHolder = new MovieClip;			addChild (PicHolder);			ButtonsClip = new MovieClip;			addChild (ButtonsClip);			ButtonsClip.visible = false;			ButtonsClip.x = ButtonsClip.y = 100;//			IMAGE LOADER LOADS SET OF IMAGES, CALLS FUNCTION WITH ARRAY WHEN DONE			var resourceArray:Array = resource.split ('|');			var urlArray:Array = [];			var urlHeader:String = resourceArray.shift ();			var NewImageButton:OptionButton;			for (var entryNum:int in resourceArray) {				urlArray.push ('MatchGame/' + urlHeader + '-' + entryNum + '.jpg');				NewImageButton = new OptionButton (resourceArray [entryNum], true, entryNum);				ButtonsClip.addChild (NewImageButton);				ButtonsAll.push (NewImageButton);			}			addChild (new ImageLoader (urlArray, setupGame));		}//		IMAGES LOADED, GAME READY		private function setupGame (_Images:Array):void {			ImagesAll = _Images;			dispatchEvent (new Event ('matchGameReady'));		}		public function resetGame (e:Object = null):void {			TweenMax.killDelayedCallsTo (pixillateImage);			if (!ImagesAll.length) return;			var randPos:Array = Util.randArray (ButtonsAll.length);			for (ind in ButtonsAll) ButtonsAll [ind].y = 40 * randPos [ind];			ButtonsClip.visible = true;			score = 0;			ImagesCopy = ImagesAll.slice ();			Util.randArray (ImagesCopy);			ButtonsActive = ButtonsAll.slice ();			stopGame ();			startGame (true);			getNextImage ();		}		public function startGame (firstTime:Boolean = false):void {			for each (Btn in ButtonsActive) Util.asButton (Btn);			if (firstTime) GameManager.instance.gameStarted ();		}		public function stopGame (gameOver:Object = false):void {			for each (Btn in ButtonsAll) Util.asButton (Btn, false);			if (gameOver) GameManager.instance.gameFeedback ();		}		public function cleanUp ():void {			removeEventListener ('buttonClick', buttonClick);			stopGame ();			TweenMax.killAll ();		}		// ********* END IGame FUNCTIONS *********		// ********* START GAME FUNCTIONS *********		// LOAD NEXT IMAGE		private function getNextImage (e:Event = null):void {			for each (Btn in ButtonsActive) {				Util.asButton (Btn, true);				Btn.alpha = .7;			}			// GET NEXT IMAGE			var ratio:Number = ImagesCopy[0].height / ImagesCopy[0].width;			Frame.scaleX = Frame.scaleY = 1;			Frame.width = (ratio > 1) ? Frame.width = Frame.height / ratio : Frame.height = Frame.width * ratio;			pixillateImage (int (Frame.width / 20));		}		// PIXILLATE IMAGE		private function pixillateImage (_pixelSize:int = 20):void {			while (PicHolder.numChildren) PicHolder.removeChildAt (0);			pixelSize = _pixelSize;			if (pixelSize <= 1) {				PicHolder.pixels = PicHolder.addChild (new Bitmap (ImagesCopy[0].bitmapData.clone (), 'auto', true));			} else {				var bmpData:BitmapData = new BitmapData (ImagesCopy[0].width / pixelSize, ImagesCopy[0].height / pixelSize, false);				PicHolder.pixels = PicHolder.addChild (new Bitmap (bmpData));				var scaleMatrix:Matrix = new Matrix ();				scaleMatrix.scale (1 / pixelSize, 1 / pixelSize);				bmpData.draw (ImagesCopy[0], scaleMatrix);				TweenMax.delayedCall (1, pixillateImage, [pixelSize * .9]);			}			Center.it (PicHolder.pixels, Frame, 1);		}		public function buttonClick (buttonEvent:Event):void {			buttonEvent.stopPropagation ();			var ClickedButton:Object = buttonEvent.target;			trace (ClickedButton.name);			Util.asButton (DisplayObject (ClickedButton), false, .3);//			CLICK ON CONTINUE BUTTON			if (ClickedButton.name.toUpperCase () == CBRXML.the().xml.buttonLabels.Continue) {				dispatchEvent (new Event ('restartTimer', true, true));				getNextImage ();//			CLICK ON CHOICE BUTTON			} else {				var pixelScore:int = Math.ceil (pixelSize);//				WRONG BUTTON PRESSED				trace (ClickedButton.number, ImagesAll.indexOf (ImagesCopy[0]));				if (ClickedButton.number != ImagesAll.indexOf (ImagesCopy[0])) {					score -= pixelScore;//				RIGHT BUTTON PRESSED				} else {					score += pixelScore;					ButtonsActive.splice (ButtonsActive.indexOf (ClickedButton), 1);					TweenMax.killDelayedCallsTo (pixillateImage);					pixillateImage (1);					ImagesCopy.shift ();					if (ImagesCopy.length) {						var popupXML:XML = <popupXML></popupXML>;						popupXML.body = CBRXML.the().xml.feedbackPos.choice [Util.randomize(CBRXML.the().xml.feedbackPos.choice.length())].toString() + ' ' + CBRXML.the().xml.MatchGame.scoreFeedback1 + ' ' + pixelScore + ' ' + CBRXML.the().xml.MatchGame.scoreFeedback2;						popupXML.options = CBRXML.the().xml.buttonLabels.Continue;						addChild (new GamePopup (popupXML));						dispatchEvent (new Event ('pauseTimer', true, true));					} else {						stopGame (true);					}				}			}		}	}}