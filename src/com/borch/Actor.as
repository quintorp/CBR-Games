package com.borch {	import flash.display.MovieClip;	import flash.events.AccelerometerEvent;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.geom.ColorTransform;	import flash.sensors.Accelerometer;	public class Actor extends MovieClip {		private const KEYS_OK:Object = { 37:'left', 38:'up', 39:'right', 40:'down', 32:'jump', 16:'duck' };		private var PAUSE_STATES:Vector.<String> = Vector.<String> (['jumping', 'dizzy', 'ducking', 'sinking']);		private var action:String;		private var facing:String;		private var state:String;		private var gameType:String;		private var keysDown:Object = {};		private var verStepSize:Number = 30;		private var horStepSize:Number = 30;		private var hor:int;		private var ver:int;		private var limitLeft:int;		private var limitRight:int;		private var limitTop:int;		private var limitBottom:int;		private var accel:Accelerometer;		private var Basket:MovieClip;		public function Actor(_gameType:String) {			super ();			stop ();			gameType = _gameType;			addEventListener (Event.ADDED_TO_STAGE, init, false, 0, true);		}		public function init(e:Event):void {			removeEventListener (Event.ADDED_TO_STAGE, init);			addEventListener (Event.REMOVED_FROM_STAGE, stopActor, false, 0, true);			Center.it (this);//			THESE LIMITS SET HOW CLOSE THE ACTOR CAN GO TO THE EDGES			limitTop = 60;			limitBottom = stage.stageHeight - 10;			limitLeft = 30;			limitRight = stage.stageWidth - 30;			switch (gameType) {				case 'Manna':					if (!Basket) Basket = addChild (new BasketClip);					Basket.stop ();					limitTop = 150;					break;				case 'Moses':					limitTop = 200;					limitBottom = stage.stageHeight - 160;					break;				case 'Jordan':					verStepSize = 15;					y = 470;					break;				case 'Paul':					y = 200;					limitLeft = 250;					limitRight = stage.stageWidth - 250;					break;			}			pausePosition ();			scaleY = scaleX = .2 + .5 * y / stage.stageHeight;		}		public function startActor(e:Event = null):void {			if (Accelerometer.isSupported) {				accel = new Accelerometer ();				accel.setRequestedUpdateInterval (100);				accel.addEventListener (AccelerometerEvent.UPDATE, tiltEvent, false, 0, true);			}			addEventListener (Event.ENTER_FRAME, update, false, 0, true);			stage.addEventListener (KeyboardEvent.KEY_DOWN, keyboardEvent, false, 0, true);			stage.addEventListener (KeyboardEvent.KEY_UP, keyboardEvent, false, 0, true);		}		public function stopActor(e:Event = null):void {			pausePosition ();			accel = null;			removeEventListener (Event.ENTER_FRAME, update);			stage.removeEventListener (KeyboardEvent.KEY_DOWN, keyboardEvent);			stage.removeEventListener (KeyboardEvent.KEY_UP, keyboardEvent);		}		private function pausePosition():void {			hor = ver = 0;			facing = 'front';			setActionAndGo ('standing');		}		private function setActionAndGo(newAction:String):void {			action = newAction;			state = action + ' ' + facing;			gotoAndStop (state, null);			if (Basket) (facing == 'back') ? Util.sendBack (Basket):Util.bringFront (Basket);		}		public function waitForActionComplete(pauseAction:String):void {			/*			 * THESE TWO FUNCTIONS LIMIT THE INTERACTION OF THE ACTOR			 * DEPENDING ON WHICH PAUSED STATE THEY ARE IN.			 * VALID PAUSE STATES (ACTIONS) ARE JUMPING, DUCKING,			 * DIZZY AND SINKING. IN DIZZY AND SINKING KEYBOARD INPUT IS IGNORED			 * AND THE ACTOR IS SET TO 'STANDING FRONT' AT THE END.			 * IN JUMPING THE KEYS DIRECT WHERE THE ACTOR MOVES (HOR AND VER)			 * BUT THE ACTOR DOES NOT CHANGE STATE UNTIL THE ACTION IS OVER.			 * THE END OF THE ACTION IS IMPLEMENTED WITH AN addFrameScript			 * */			action = pauseAction;			if (action == 'jumping') {				state = action + ' ' + facing;			} else {				facing = 'front';				state = action;				hor = ver = 0;				keysDown = null;				keysDown = {};			}			gotoAndStop (state);			if (Basket) (facing == 'back') ? Util.sendBack (Basket):Util.bringFront (Basket);			Body.addFrameScript (Body.totalFrames - 1, resume);		}		private function resume(e:Event = null):void {			Body.addFrameScript (Body.totalFrames - 1, null);			if ((gameType == 'Jordan') && (action == 'sinking')) {				x = stage.stageWidth / 2;				y = stage.stageHeight - 50;			}			setActionAndGo (((action == 'jumping') && ((hor == 1) || (ver == 1))) ? 'walking':'standing')		}		private function update(e:Event = null):void {			/* THE MOVE FUNCTION IS LIMITED DEPENDING ON			 * WHAT STATE THE ACTOR IS IN. IF PAUSED AND NOT JUMPING			 * THE FUNCTION EXITS. IF NOT JUMPING THE STATE IS UPDATED			 * */			if ((isPaused) && (action != 'jumping')) return;			if (action != 'jumping') {				action = ((hor == 0) && (ver == 0)) ? 'standing':'walking';				state = (action + ' ' + facing);			}			if (currentFrameLabel != state) {				gotoAndStop (state);				if (Basket) (facing == 'back') ? Util.sendBack (Basket):Util.bringFront (Basket);			}			moveActorOrBackground ();		}		private function tiltEvent(accelEvent:AccelerometerEvent):void {			hor = (Math.abs (accelEvent.accelerationX) < .2) ? 0:1 - 2 * int (accelEvent.accelerationX > 0);			ver = (Math.abs (accelEvent.accelerationY) < .2) ? 0:1 - 2 * int (accelEvent.accelerationY < 0);			setFacing ();		}		private function keyboardEvent(k:KeyboardEvent):void {			if ((isPaused) && (action != 'jumping') && (action != 'ducking')) return;			if (k.type == 'keyDown') {				if ((k.keyCode in keysDown) || (!(k.keyCode in KEYS_OK))) return;				keysDown [k.keyCode] = true;				if (k.keyCode == 16) {					setActionAndGo ('ducking');					return;				}			} else {				delete keysDown [k.keyCode];			}			switch (k.keyCode) {				case 16:					setActionAndGo ('standing');					return;				case 32:					waitForActionComplete ('jumping');					return;				case 37 :					hor = (k.type == 'keyDown') ? -1:0;					break;				case 38 :					ver = (k.type == 'keyDown') ? -1:0;					break;				case 39 :					hor = (k.type == 'keyDown') ? 1:0;					break;				case 40 :					ver = (k.type == 'keyDown') ? 1:0;					break;			}			setFacing ();		}		private function setFacing():void {			if (hor == 1) {				facing = 'right';				if (Basket) Util.bringFront (Basket);			} else if (hor == -1) {				facing = 'left';				if (Basket) Util.bringFront (Basket);			} else if (ver == -1) {				facing = 'back';				if (Basket) Util.sendBack (Basket);			} else if (ver == 1) {				facing = 'front';				if (Basket) Util.bringFront (Basket);			}		}		public function get isPaused():Boolean {			return (Boolean (PAUSE_STATES.indexOf (action) != -1));		}		public function get maxX():int {			return limitRight;		}		private function moveActorOrBackground():void {			if (hor == -1) {				if ((x - scaleY * horStepSize) < limitLeft) {					dispatchEvent (new Event ('moveFieldRight'));				} else {					x -= scaleY * horStepSize;				}			} else if (hor == 1) {				if ((x + scaleY * horStepSize) > limitRight) {					dispatchEvent (new Event ('moveFieldLeft'));				} else {					x += scaleY * horStepSize;				}			}			if (ver == -1) {				if ((y - scaleY * verStepSize) < limitTop) {					dispatchEvent (new Event ('moveFieldDown'));				} else {					y -= scaleY * verStepSize;				}			} else if (ver == 1) {				if ((y + scaleY * verStepSize) > limitBottom) {					dispatchEvent (new Event ('moveFieldUp'));				} else {					y += scaleY * verStepSize;				}			}			scaleY = scaleX = .2 + .5 * y / stage.stageHeight;		}		public function addManna(reset:Boolean = true):int {			if (reset) {				var mannaCount:int = Basket.currentFrame - 1;				if (Basket.currentFrame > 1) {					Basket.transform.colorTransform = new ColorTransform ();					Basket.gotoAndStop (1);				}				return mannaCount;			}			if (Basket.currentFrame >= Basket.totalFrames) {				waitForActionComplete ('dizzy');				return 0;			}			var basketColor:ColorTransform = Basket.transform.colorTransform;			basketColor.redOffset += 25;			Basket.transform.colorTransform = basketColor;			Basket.nextFrame ();			return 0;		}	}}// fish front,stand front,stand back,walk front,walk back,climb front,climb back,duck front,duck back,jump front,jump back,stand left,walk left,stand right,walk right,duck left,duck right,jump left,jump right,dizzy,sinking