package com.borch {	import com.greensock.*;	import com.greensock.easing.*;	import com.greensock.plugins.*;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.geom.ColorTransform;	import flash.geom.Rectangle;	import flash.ui.Mouse;	import flash.utils.getTimer;	public class ColorGame extends MovieClip implements IGame {		private var Drawing:MovieClip;		private var Brush:MovieClip;		private var MagnifyBtn:MovieClip;		private var Palette:MovieClip;		private const ZOOMS:Array = [0, 3, .8];		private var colorCount:int;		private var throwBounds:Rectangle;		private var timeStart:int, timeStop:int, yInit:Number, yStart:Number, yStop:Number, xInit:Number, xStart:Number, xStop:Number, xOverlap:Number, xOffset:Number, yOverlap:Number, yOffset:Number;		public function ColorGame () {			super ();			TweenPlugin.activate ([ThrowPropsPlugin]);		}		public function initGame (Resource:Object = null):void {//			var iconInfo : String = GameManager.instance.gameXML.about.toString ();			Drawing = MovieClip (Resource);			Drawing.stop ();			Drawing.myOutline.visible = false;			var BD:Backdrop = new Backdrop (Drawing, 0xffffff, 1, true, false);			Drawing.addChildAt (BD, 0);			addChildAt (Drawing, 0);			Palette = addChild (new PaletteClip ());			Palette.height = stage.stageHeight;			MagnifyBtn = addChild (new MagnifyBtnClip ())			MagnifyBtn.x = 610;			MagnifyBtn.y = stage.stageHeight - MagnifyBtn.height - 10;			Brush = addChild (new BrushClip ());			Brush.visible = false;			MagnifyBtn.gotoAndStop (2);			resizeDrawing ();		}		public function resetGame (option:Object = null):void {			MagnifyBtn.gotoAndStop (2);			resizeDrawing ();			Drawing.myOutline.visible = (option && (option == 1)) ? false : true;			var Pieces:Array = Util.childArray (Drawing);			var white:ColorTransform = new ColorTransform (1, 1, 1, 1, 0, 0, 0, 0);			Brush.Tip.transform.colorTransform = white;			for each (var Piece:DisplayObject in Pieces) Piece.transform.colorTransform = white;			Drawing.addEventListener (MouseEvent.MOUSE_DOWN, firstTime, false, 0, true);			stopGame ();			startGame (true);		}		private function firstTime (e:MouseEvent):void {			Drawing.removeEventListener (MouseEvent.MOUSE_DOWN, firstTime);			GameManager.instance.gameStarted ();		}		public function startGame (firstTime:Boolean = false):void {			Util.asButton (MagnifyBtn);			MagnifyBtn.addEventListener (MouseEvent.CLICK, resizeDrawing, false, 0, true);			Drawing.addEventListener (MouseEvent.ROLL_OVER, showBrush, false, 0, true);			Drawing.addEventListener (MouseEvent.MOUSE_MOVE, moveBrush, false, 0, true);			Drawing.addEventListener (MouseEvent.MOUSE_UP, paintPart, false, 0, true);			Drawing.addEventListener (MouseEvent.ROLL_OUT, hideBrush, false, 0, true);			Palette.addEventListener (MouseEvent.ROLL_OVER, showBrush, false, 0, true);			Palette.addEventListener (MouseEvent.MOUSE_MOVE, moveBrush, false, 0, true);			Palette.addEventListener (MouseEvent.MOUSE_UP, pickColor, false, 0, true);			Palette.addEventListener (MouseEvent.ROLL_OUT, hideBrush, false, 0, true);		}		public function stopGame (gameOver:Object = false):void {			Util.asButton (MagnifyBtn, false);			Mouse.show ();			MagnifyBtn.removeEventListener (MouseEvent.CLICK, resizeDrawing);			Drawing.removeEventListener (MouseEvent.ROLL_OVER, showBrush);			Drawing.removeEventListener (MouseEvent.MOUSE_DOWN, prepForThrow);			Drawing.removeEventListener (MouseEvent.MOUSE_MOVE, moveBrush);			Drawing.removeEventListener (MouseEvent.MOUSE_UP, paintPart);			Drawing.removeEventListener (MouseEvent.ROLL_OUT, hideBrush);			Palette.removeEventListener (MouseEvent.ROLL_OVER, showBrush);			Palette.removeEventListener (MouseEvent.MOUSE_MOVE, moveBrush);			Palette.removeEventListener (MouseEvent.MOUSE_UP, pickColor);			Palette.removeEventListener (MouseEvent.ROLL_OUT, hideBrush);			if (gameOver) GameManager.instance.gameFeedback ();		}		public function cleanUp ():void {			stopGame ();			Mouse.show ();			TweenMax.killAll (false, true, true);		}//		********* END IGame FUNCTIONS *********//		********* START GAME FUNCTIONS *********		private function showBrush (m:MouseEvent = null):void {			Brush.visible = true;			Mouse.hide ();		}		private function hideBrush (m:MouseEvent = null):void {			Brush.visible = false;			Mouse.show ();		}		private function moveBrush (m:MouseEvent):void {			Brush.alpha = (m.target.name == 'myOutline') ? .5 : 1;			Brush.x = mouseX;			Brush.y = mouseY;			m.updateAfterEvent ();		}		private function paintPart (m:MouseEvent):void {//			IGNORE MOVES (RATHER THAN CLICKS)			if (Math.sqrt (Math.pow (xStart - xStop, 2) + Math.pow (yStart - yStop, 2)) > 2) return;			if ((m.target.name != 'myOutline') && (m.target.parent.getChildIndex (m.target) != 0)) {				m.target.transform.colorTransform = Brush.Tip.transform.colorTransform;				if (!m.target.isColored) { // PART ALREADY PAINTED					m.target.isColored = true;					++colorCount;					if (colorCount == m.target.parent.numChildren - 3) {						Drawing.myOutline.visible = true;						stopGame (true);					}				}// 		   Cursor.Tip.play ();				m.updateAfterEvent ();			}		}//	   GET COLOR FROM PICKER		private function pickColor (m:MouseEvent):void {			Brush.Tip.transform.colorTransform = m.target.transform.colorTransform;		}//		ZOOM IMAGE FUNCTION		private function resizeDrawing (m:MouseEvent = null):void {			Center.it (Drawing, stage, (int (Drawing.height < Drawing.width) - 2));			var size:Number = ZOOMS [MagnifyBtn.currentFrame];			Drawing.width *= size;			Drawing.height *= size;			Center.it (Drawing);			if (MagnifyBtn.currentFrame == 1) {				MagnifyBtn.gotoAndStop (2);				throwBounds = stage.getBounds (Drawing);				throwBounds.x = -1 * (throwBounds.x - 90);				throwBounds.y = -1 * (throwBounds.y - 20);				throwBounds.width = stage.stageWidth - 170;				throwBounds.height = stage.stageHeight - 60;				Drawing.addEventListener (MouseEvent.MOUSE_DOWN, prepForThrow, false, 0, true);			} else {				MagnifyBtn.gotoAndStop (1);				Drawing.removeEventListener (MouseEvent.MOUSE_DOWN, prepForThrow);			}		}//		CREATE AREA FOR CONTROLLING ZOOMED DRAWING		private function prepForThrow (event:MouseEvent):void {			TweenLite.killTweensOf (Drawing);			xInit = xStart = xStop = Drawing.x;			xOffset = this.mouseX - Drawing.x;			xOverlap = Math.max (0, Drawing.width - throwBounds.width);			yInit = yStart = yStop = Drawing.y;			yOffset = this.mouseY - Drawing.y;			yOverlap = Math.max (0, Drawing.height - throwBounds.height);			timeStart = timeStop = getTimer ();			stage.addEventListener (MouseEvent.MOUSE_MOVE, throwDrawing);			stage.addEventListener (MouseEvent.MOUSE_UP, releaseDrawing);		}		private function throwDrawing (event:MouseEvent):void {			var y:Number = this.mouseY - yOffset;			//if Drawing's position exceeds the bounds, make it drag only half as far with each mouse movement (like iPhone/iPad behavior)			if (y > throwBounds.top) {				Drawing.y = (y + throwBounds.top) * 0.5;			} else if (y < throwBounds.top - yOverlap) {				Drawing.y = (y + throwBounds.top - yOverlap) * 0.5;			} else {				Drawing.y = y;			}			var x:Number = this.mouseX - xOffset;			if (x > throwBounds.left) {				Drawing.x = (x + throwBounds.left) * 0.5;			} else if (x < throwBounds.left - xOverlap) {				Drawing.x = (x + throwBounds.left - xOverlap) * 0.5;			} else {				Drawing.x = x;			}			var t:uint = getTimer ();			//if the frame rate is too high, we won't be able to track the velocity as well, so only update the values 20 times per second			if (t - timeStop > 50) {				xStop = xStart;				xStart = Drawing.x;				yStop = yStart;				timeStop = timeStart;				yStart = Drawing.y;				timeStart = t;			}			event.updateAfterEvent ();		}		private function releaseDrawing (event:MouseEvent):void {			stage.removeEventListener (MouseEvent.MOUSE_UP, releaseDrawing);			stage.removeEventListener (MouseEvent.MOUSE_MOVE, throwDrawing);			var time:Number = (getTimer () - timeStop) / 1000;			var xVelocity:Number = (Drawing.x - xStop) / time;			var yVelocity:Number = (Drawing.y - yStop) / time;			ThrowPropsPlugin.to (Drawing, {throwProps : {				y : {velocity : yVelocity, max : throwBounds.top, min : throwBounds.top - yOverlap, resistance : 300},				x : {velocity : xVelocity, max : throwBounds.left, min : throwBounds.left - xOverlap, resistance : 300}			}, ease : Strong.easeOut }, 10, 0.3, 1);		}		public function get Printable ():MovieClip {			return Drawing;		}	}}