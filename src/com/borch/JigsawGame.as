/* This game has been re-worked so that puzzle images can be JPGs (as opposed to SWFs). To use, simply place a jpg of an appropriate size: can be bigger than 480px in largest dimension should not be smaller or will pixellate. should not be too much bigger for file size/speed height/width ratio should be between .75 and 1.3 */package com.borch {	import com.greensock.*;	import flash.display.Bitmap;	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.filters.DropShadowFilter;	import flash.filters.GlowFilter;	import flash.geom.Point;	import flash.geom.Rectangle;	import org.casalib.util.AlignUtil;	public class JigsawGame extends MovieClip implements IGame {		private var offGlow:GlowFilter = new GlowFilter (0xFF0000, 1, 8, 8, 64, 1, true, false);		private var onGlow:GlowFilter = new GlowFilter (0xFFFFFF, 1, 8, 8, 64, 1, true, false);		private var dragShadow:DropShadowFilter = new DropShadowFilter (8, 45, 0, 1, 4, 4, 1, 1, false, false, false);		private var PuzzleClip:MovieClip;		private var Puzzle:Array = [];		private var LivePieces:Array = [];		private var ActivePiece:MovieClip;		private var distance:int;		private var Image:Bitmap;		private var Piece:MovieClip;		private var level:int = 0;		private var classes:Array = [PieceClip9, PieceClip19];		public function JigsawGame () {			super ();		}		public function initGame (resource:Object = null):void {			Image = Bitmap (resource);			addChild (Image);			Image.alpha = 0;			var aspect:int = Number ((Image.height / Image.width) < 1) - 2;			Center.it (Image, Frame, aspect);		}		public function resetGame (option:Object = null):void {			if (option != null) level = int (option);			var PuzzleClass:Class;			var startAlpha:Number;			if (level) {				startAlpha = 0;				PuzzleClass = PieceClip19;				distance = 40;			} else {				startAlpha = .2;				PuzzleClass = PieceClip9;				distance = 80;			}			// ADD UNDERLAY Image AND SCALE			if (!PuzzleClip) {				PuzzleClip = MovieClip (new PuzzleClass);				addChild (PuzzleClip);				var imageRect:Rectangle = Image.getBounds (stage);				PuzzleClip.width = Frame.width = imageRect.width;				PuzzleClip.height = Frame.height = imageRect.height;				PuzzleClip.x = Frame.x = imageRect.x;				PuzzleClip.y = Frame.y = imageRect.y;				// SETUP GAME PIECES				Puzzle = Util.childArray (PuzzleClip);				for each (Piece in Puzzle) {					var BMP:Bitmap = new Bitmap (Image.bitmapData.clone ());					Piece.addChild (BMP);					BMP.scaleX = Image.scaleX / PuzzleClip.scaleX;					BMP.scaleY = Image.scaleY / PuzzleClip.scaleY;					AlignUtil.alignMiddleCenter (BMP, Image.getBounds (Piece));					BMP.mask = Piece.getChildAt (0);					Piece.startX = Piece.x;					Piece.startY = Piece.y;				}			}			Image.alpha = startAlpha;			for each (Piece in Puzzle) resetPuzzlePiece (Piece);			LivePieces = Puzzle.slice ();			PuzzleClip.addEventListener (MouseEvent.MOUSE_DOWN, firstTime, false, 0, true);			stopGame ();			startGame (true);		}		private function firstTime (e:MouseEvent):void {			e.target.removeEventListener (MouseEvent.MOUSE_DOWN, firstTime);			GameManager.instance.gameStarted ();		}		public function startGame (firstTime:Boolean = false):void {			PuzzleClip.addEventListener (MouseEvent.MOUSE_OVER, mousePiece, false, 0, true);			PuzzleClip.addEventListener (MouseEvent.MOUSE_DOWN, mousePiece, false, 0, true);			PuzzleClip.addEventListener (MouseEvent.MOUSE_OUT, mousePiece, false, 0, true);			PuzzleClip.addEventListener (MouseEvent.MOUSE_UP, checkPosition, false, 0, true);		}		public function stopGame (gameOver:Object = false):void {			PuzzleClip.removeEventListener (MouseEvent.MOUSE_OVER, mousePiece);			PuzzleClip.removeEventListener (MouseEvent.MOUSE_DOWN, mousePiece);			PuzzleClip.removeEventListener (MouseEvent.MOUSE_OUT, mousePiece);			PuzzleClip.removeEventListener (MouseEvent.MOUSE_UP, checkPosition);			if (gameOver) {				GameManager.instance.gameFeedback ();				TweenMax.to (Image, 1, { alpha : 1, delay : 1 });				for each (Piece in Puzzle) TweenMax.to (Piece, 1, { alpha : 0, rotation : 360 - Math.random () * 720, delay : 1 });			}		}		public function solveGame ():void {			for each (Piece in Puzzle) resetPiece (Piece, true);			TweenMax.to (Image, 2, { alpha : 1 });			stopGame ();		}		public function cleanUp ():void {			stopGame ();			TweenMax.killAll ();		}		// ********* END IGame FUNCTIONS *********		// ********* START GAME FUNCTIONS *********		// ADD GAME CLIP AND CENTER		private function resetPuzzlePiece (Piece:MovieClip):void {			Piece.x = 200 * Math.random () - PuzzleClip.x;			Piece.y = 500 * Math.random ();			Piece.alpha = 1;			Piece.visible = true;			Piece.rotation = 0;			Util.asButton (Piece);			Piece.filters = [offGlow];		}		private function mousePiece (e:MouseEvent):void {			if (!e.target.buttonMode) return;			Piece = MovieClip (e.target);			switch (e.type) {				case 'mouseOver':					Util.bringFront (Piece);					Piece.filters = [onGlow];					break;				case 'mouseOut':					Piece.filters = [offGlow];					break;				case 'mouseDown':					ActivePiece = Piece;					ActivePiece.filters = [onGlow, dragShadow];					stage.addEventListener (MouseEvent.MOUSE_MOVE, dragPiece, false, 0, true);					break;			}		}		private function dragPiece (m:MouseEvent):void {			ActivePiece.x = PuzzleClip.mouseX;			ActivePiece.y = PuzzleClip.mouseY;			m.updateAfterEvent ();		}		private function checkPosition (e:MouseEvent):void {			stage.removeEventListener (MouseEvent.MOUSE_MOVE, dragPiece);			ActivePiece.filters = [onGlow];			// NOT SET CORRECTLY			if (Util.distance (new Point (ActivePiece.x, ActivePiece.y), new Point (ActivePiece.startX, ActivePiece.startY)) > distance) return;			// SET CORRECTLY			resetPiece (ActivePiece);			ActivePiece = null;			if (!LivePieces.length) stopGame (true);		}		private function resetPiece (Piece:MovieClip, slow:Boolean = false):void {			LivePieces.splice (LivePieces.indexOf (Piece), 1);			Util.sendBack (Piece);			TweenMax.to (Piece, .3 + 1.7 * int (slow), { x : Piece.startX, y : Piece.startY, rotation : 0 });			Piece.alpha = 1;			Piece.filters = [];			Util.asButton (Piece, false, 1);		}	}}