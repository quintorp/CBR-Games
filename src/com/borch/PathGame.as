package com.borch {	import com.greensock.*;	import flash.display.MovieClip;	import flash.events.AccelerometerEvent;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.geom.ColorTransform;	import flash.geom.Rectangle;	import flash.sensors.Accelerometer;	import flash.text.TextFormat;	import org.casalib.layout.Distribution;	public class PathGame extends MovieClip implements IGame {		private var gameXML:XML;		private var letter:String;		private var ltr:int;		private var phraseLength:int;		private var Letter:MovieClip;		private var Letters:Array = [];		private var DupeLetters:Array = [];		private var Layout:Distribution;		private var DupeLayout:MovieClip;		private var colorXform:ColorTransform = new ColorTransform (1, 1, 1, 1, 255, -255, -255, 0);		private var noXform:ColorTransform = new ColorTransform (1, 1, 1, 1, 0, 0, 0, 0);		private var moveDirections:Array = [];		private var columns:int;		private var lettersSoFar:int;		private var PathMan:MovieClip;		private var keyMove:Object;		private const KEY_DIR:Object = { 37 : 'l', 38 : 'u', 39 : 'r', 40 : 'd' };		private var moveSensor:Accelerometer;		private var moveArray:Array;		private const MOVE_DIRS:Object = { l : [-1, 0], u : [0, -1], r : [1, 0], d : [0, -1] };		private var classes:Array = [ Class (PathLetter), Class (PathManClip) ];		public function PathGame () {			super ();		}		public function initGame (resource:Object = null):void {			XML.ignoreWhitespace = false;			gameXML = new XML (resource);			gameXML.filledInGrid = Util.fillInBlanks (gameXML.grid);			var gridArray:Array = gameXML.filledInGrid.split ('');			PhraseField.htmlText = gameXML.phrase + '\n<font color="000000" size="-4">(' + gameXML.@ref + ')</font>';			columns = Math.floor (Math.sqrt (gridArray.length));			keyMove = { l : -1, u : -columns, r : 1, d : columns };			// MAKE LETTER ARRAY			for each (letter in gridArray) {				var NewLetter:MovieClip = new PathLetter;				NewLetter.puzLtr.text = letter;				Letters.push (NewLetter);			}			if (Accelerometer.isSupported) {				moveSensor = new Accelerometer ();				moveSensor.setRequestedUpdateInterval (20);				moveSensor.addEventListener (AccelerometerEvent.UPDATE, getTilt);			}		}		public function resetGame (option:Object = null):void {			if (!Layout) {				Layout = Distribution (addChild (new Distribution));				for each (Letter in Letters) Layout.addChild (Letter);				Layout.size = Letters[0].width * columns;				Layout.position ();				Center.it (Layout, PuzRect, 1);				PathMan = Layout.addChild (new PathManClip);				PhraseField.visible = !option;			}			for each (Letter in Letters) Letter.transform.colorTransform = noXform;			Layout.alpha = 1;			Destroy.it (DupeLayout);			DupeLetters = [];			var textXformNone:TextFormat = new TextFormat (null, null, 0);			PhraseField.setTextFormat (textXformNone);			lettersSoFar = 0;			moveDirections = gameXML.dirs.split ('');			PathMan.loc = int (gameXML.@start);			PathMan.x = Letters[PathMan.loc].x;			PathMan.y = Letters[PathMan.loc].y;			stage.addEventListener (KeyboardEvent.KEY_DOWN, firstTime, false, 0, true);			moveArray = [0, 0];			stopGame ();			startGame (true);			phraseLength = gameXML.phrase.toString().length;		}		private function firstTime (k:KeyboardEvent = null):void {			stage.removeEventListener (KeyboardEvent.KEY_DOWN, firstTime);			GameManager.instance.gameStarted ();		}		public function startGame (firstTime:Boolean = false):void {			stage.addEventListener (KeyboardEvent.KEY_DOWN, checkArrowPress, false, 0, true);			stage.focus = stage;		}		public function stopGame (gameOver:Object = false):void {			stage.removeEventListener (KeyboardEvent.KEY_DOWN, checkArrowPress);			if (gameOver) {				GameManager.instance.gameFeedback ();				moveLettersIntoPhrase ();				PhraseField.setTextFormat (new TextFormat (null, null, 0xDD0000));			}		}		public function solveGame ():void {			getNextLetter (true);		}		public function cleanUp ():void {			sensor = null;			stopGame ();			TweenMax.killAll ();			Destroy.it (this);		}		// ********* END IGame FUNCTIONS *********		// ********* START GAME FUNCTIONS *********		// HANDLE ARROW KEYS		private function checkArrowPress (k:KeyboardEvent):void {			if (KEY_DIR [k.keyCode] && (KEY_DIR [k.keyCode] == moveDirections[0])) getNextLetter ();		}		private function getTilt (a:AccelerometerEvent):void {			var moveX:int = (Math.abs (a.accelerationX) < .3) ? 0 : -Util.sign (a.accelerationX);			var moveY:int = (Math.abs (a.accelerationY) < .3) ? 0 : -Util.sign (a.accelerationY);			if ((moveX == moveArray[0]) && (moveY == moveArray[1])) return;			moveArray = [moveX, moveY];			if ((moveArray [0] == MOVE_DIRS[moveDirections[0]][0]) && (moveArray[1] == MOVE_DIRS[moveDirections[0]][1])) getNextLetter ();		}		private function getNextLetter (auto:Boolean = false):void {			var dir:String = moveDirections.shift ();			var KEY_ROT:Object = { l : 180, u : 270, r : 0, d : 90 };			PathMan.rotation = KEY_ROT [dir];			PathMan.loc += keyMove [dir];			var NextLetter:MovieClip = Letters [PathMan.loc];			NextLetter.transform.colorTransform = colorXform;			var recursive:Function = (auto && moveDirections.length) ? getNextLetter : null;			TweenMax.to (PathMan, .01, { x : NextLetter.x, y : NextLetter.y, onComplete : recursive, onCompleteParams : [auto] });			if (! moveDirections.length) {				stopGame (true);				return;			}//			HIGHLIGHT THE PHRASEFIELD TEXT			do { ++lettersSoFar } while ((lettersSoFar <= (phraseLength - 1)) && (gameXML.phrase.charAt (lettersSoFar).search (/[a-zA-Z]/) == -1));			var textXformRed:TextFormat = new TextFormat (null, null, 0xDD0000);			PhraseField.setTextFormat (textXformRed, 0, lettersSoFar);		}		private function moveLettersIntoPhrase ():void {			// PUZRECT IS PLACEHOLDER/GIVES X/Y LOC FOR LETTERS			PuzRect.text = PhraseField.text.toUpperCase ();			PuzRect.width = Math.sqrt (PuzRect.textHeight * PuzRect.width);			PuzRect.height = PuzRect.textHeight;			PuzRect.scaleX = PuzRect.scaleY = Layout.scaleX;			Center.it (PuzRect, Layout, 0);			// MAKE DUPLICATE CLIP			DupeLayout = addChild (new MovieClip);			DupeLayout.alpha = 0;			DupeLayout.scaleX = Layout.scaleX;			DupeLayout.scaleY = Layout.scaleY;			DupeLayout.x = Layout.x;			DupeLayout.y = Layout.y;			// ADD LETTER CLIPS TO DUPE CLIP			var phrase:Array = gameXML.phrase.toUpperCase ().split ('');			for each (letter in phrase) {				NewLetter = DupeLayout.addChild (new PathLetter);				NewLetter.puzLtr.text = letter;				DupeLetters.push (NewLetter);			}			// PLACE DUPE LETTER CLIPS IN PLACE ON GRID			var nextLetterLoc:int = 0;			moveDirections = gameXML.dirs.split ('');			for (ltr in DupeLetters) {				if (phrase [ltr] != ' ') {					nextLetterLoc += keyMove [moveDirections.shift ()];					DupeLetters [ltr].x = Letters [nextLetterLoc].x + 30;					DupeLetters [ltr].y = Letters [nextLetterLoc].y;				}			}			TweenMax.to (Layout, .3, { alpha : 0 });			TweenMax.to (DupeLayout, .3, { alpha : 1 });			// MOVE DUPE LETTER CLIPS INTO PHRASE			var letterBounds:Rectangle;			for (ltr in DupeLetters) {				letterBounds = PuzRect.getCharBoundaries (ltr);				if (DupeLetters[ltr].puzLtr.text == 'I') letterBounds.x -= 4;				TweenMax.to (DupeLetters [ltr], 1, { x : letterBounds.x, y : letterBounds.y, delay : 1 });				Util.cycleColor (DupeLetters [ltr]);			}			PuzRect.visible = false;			TweenMax.to (DupeLayout, 1, { x : PuzRect.x, y : PuzRect.y, delay : 1 });		}	}}