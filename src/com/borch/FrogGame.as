package com.borch {	import com.greensock.TweenMax;	import com.greensock.easing.Elastic;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.filters.GlowFilter;	import flash.geom.Rectangle;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.ui.Mouse;	public class FrogGame extends MovieClip implements IGame {		private var Cursor:MovieClip;		private var FrogHolder:MovieClip;		private var Turtle:MovieClip;		private var FrogCount:TextField;		private const DELAYS:Array = [2, .7];		private var initDelay:Number = DELAYS [0];		private var gameDelay:Number;		private var Frogs:Array = [];		private var pondRect:Rectangle;		public function FrogGame () {			super ();		}		public function initGame (resource:Object = null):void {			addChild (makeCounterField ());			Util.asButton (Pond, false, 1);			FrogHolder = new MovieClip;			addChild (FrogHolder);			pondRect = Pond.getBounds (stage);			Turtle = new TurtleClip;			addChild (Turtle);			Turtle.mask = Mask;			Center.it (Turtle);			Turtle.addEventListener (MouseEvent.CLICK, clickTurtle, false, 0, true);			Cursor = new CursorClip;			addChild (Cursor);			Util.asButton (Cursor, false, 1);		}		private function makeCounterField ():TextField {			FrogCount = new TextField ();			FrogCount.defaultTextFormat = new TextFormat ('_sans', 18, 0, true, false, false, null, null, 'right');			FrogCount.width = 60;			FrogCount.x = 20;			FrogCount.y = 60;			FrogCount.height = 28;			FrogCount.width = 150;			FrogCount.filters = [new GlowFilter (0xffffff, 1, 4, 4)];			return FrogCount;		}		public function resetGame (option:Object = null):void {			if (option != null) initDelay = DELAYS [option];			gameDelay = initDelay;			resetTurtle ();			while (FrogHolder.numChildren) FrogHolder.removeChildAt (0);			stopGame ();			TweenMax.delayedCall (2, startGame, [true]);		}		public function startGame (firstTime:Boolean = false):void {			Turtle.addEventListener (MouseEvent.CLICK, clickTurtle, false, 0, true);			addEventListener (Event.ENTER_FRAME, moveTurtle, false, 0, true);			stage.addEventListener (MouseEvent.MOUSE_MOVE, moveCursor, false, 0, true);			addFrog ();			Cursor.visible = true;			Mouse.hide ();			if (firstTime) GameManager.instance.gameStarted ();		}		public function stopGame (gameOver:Object = false):void {			Turtle.removeEventListener (MouseEvent.CLICK, clickTurtle);			removeEventListener (Event.ENTER_FRAME, moveTurtle);			stage.removeEventListener (MouseEvent.MOUSE_MOVE, moveCursor);			TweenMax.killDelayedCallsTo (addFrog);			Cursor.visible = false;			Mouse.show ();			if (gameOver) GameManager.instance.gameFeedback ();		}		public function cleanUp ():void {			stopGame ();			Mouse.show ();			TweenMax.killAll ();		}		// ********* END IGame FUNCTIONS *********		// ********* START GAME FUNCTIONS *********		private function clickTurtle (e:MouseEvent = null):void {			TweenMax.to (Turtle, 2, { alpha : 0, onComplete : resetTurtle });		}		private function resetTurtle ():void {			switch (Util.randomize (4)) {				case 0: // TOP					Turtle.x = pondRect.x + pondRect.width * Math.random ();					Turtle.y = pondRect.y;					Turtle.rotation = -67 - 45 * Math.random ();					break;				case 1: // BOTTOM					Turtle.x = pondRect.x + pondRect.width * Math.random ();					Turtle.y = pondRect.y + pondRect.height;					Turtle.rotation = 67 + 45 * Math.random ();					break;				case 2: // LEFT					Turtle.y = pondRect.y + pondRect.height * Math.random ();					Turtle.x = pondRect.x;					Turtle.rotation = 157 + 45 * Math.random ();					break;				case 3: // RIGHT					Turtle.y = pondRect.y + pondRect.height * Math.random ();					Turtle.x = pondRect.x + pondRect.width;					Turtle.rotation = -77 + 45 * Math.random ();					break;			}			Turtle.deltaRotation = 3 * Util.neg () * Math.random ();			Turtle.alpha = 1;		}		private function moveTurtle (e:Event):void {			if (Turtle.alpha != 1) return;			Turtle.rotation += Turtle.deltaRotation;			Turtle.x -= 10 * Math.cos (Math.PI * Turtle.rotation / 180);			Turtle.y -= 10 * Math.sin (Math.PI * Turtle.rotation / 180);			if (!(Turtle.hitTestObject (Pond))) resetTurtle ();			for each (var Frog:MovieClip in Frogs) if (Frog.hitTestPoint (Turtle.x, Turtle.y, true)) Destroy.it (Frog, .5);		}		private function addFrog ():void {			gameDelay *= .99;			var NewFrog:FrogPond = new FrogPond ();			// TRY 30 DIFFERENT EMPTY SPOTS			var i:int = 30;			while (--i) {				NewFrog.x = pondRect.x + 30 + ((pondRect.width - 60) * Math.random ());				NewFrog.y = pondRect.y + 30 + ((pondRect.height - 120) * Math.random ());				var okLoc:Boolean = true;				for each (Frog in Frogs) if (NewFrog.hitTestObject (Frog)) okLoc = false;				if (okLoc) break;			}			var frogScale:Number = .7 + .5 * (NewFrog.y / stage.stageHeight);			var frogFlip:int = Util.neg ();			rotateEye (NewFrog);			Frogs.push (NewFrog);			NewFrog.scaleY = .1;			NewFrog.scaleX = frogFlip * .1;			FrogHolder.addChild (NewFrog);			TweenMax.to (NewFrog, 1, {scaleX : frogScale * frogFlip, scaleY : frogScale, ease : Elastic.easeOut });			NewFrog.addEventListener (MouseEvent.CLICK, Destroy.it, false, 0, true);			FrogCount.text = CBRXML.the().xml.gamesXref.FrogGame.frogCnt + ' ' + FrogHolder.numChildren;			TweenMax.delayedCall (gameDelay, addFrog);			if (FrogHolder.numChildren > 30) stopGame (true);		}		private static function rotateEye (Frog:MovieClip):void {			Frog.Eye.rotation = 360 * Math.random ();			TweenMax.delayedCall (3 * Math.random (), rotateEye, [Frog]);		}		// MOVE CURSOR TO MOUSE COORDS AND CALCULATE ANGLE FOR PLAYER TO ROTATION		private function moveCursor (event:MouseEvent):void {			if (Pond.hitTestPoint (mouseX, mouseY)) {				Mouse.hide ();				Cursor.visible = true;				Cursor.x = mouseX;				Cursor.y = mouseY;				event.updateAfterEvent ();			} else {				Mouse.show ();				Cursor.visible = false;			}		}	}}