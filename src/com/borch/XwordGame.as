package com.borch {	import com.greensock.*;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.events.TextEvent;	import flash.geom.ColorTransform;	import flash.geom.Rectangle;	import flash.text.StyleSheet;	import flash.text.TextFormat;	import org.casalib.layout.Distribution;	public class XwordGame extends MovieClip implements IGame {		private var gameXML:XML;             // GAME XML DATA		private var entry:XML;               // ENTRY XML		private var Puzzle:MovieClip = new MovieClip ();        // MOVIECLIP HOLDER FOR PRINTABLE		private var Layout:Distribution;     // MOVIECLIP OF LETTER CLIPS		private var Squares:Array = [];      // ARRAY OF ALL ACTIVE LETTER SQUARES		private var Square:XwdLtrClip;       // LETTER SQUARE HOLDER		private var SquaresAcross:Array = [];// SUBSET OF SQUARES GOING ACROSS		private var SquaresDown:Array = [];  // SUBSET OF SQUARES GOING DOWN		private var ActiveSquare:MovieClip;  // ACTIVELY SELECTED SQUARE		private var numColumns:int;          // NUMBER OF COLUMNS IN GRID		private var gridLength:int;          // SIZE OF GRID		private var across:Boolean;          // FLAG TO INDICATE ACTIVE DIRECTION		private var NewSquare:XwdLtrClip     // PLACEHOLDER TO LOAD CLASS		private var DirArrow:DirMarker;      // DIRECTION MARKER		private var HiliteRect:Sprite        // BOX TO HILITE ACTIVE CLUE		private var i:int;		public function XwordGame () {			super ();		}		public function initGame (resource:Object = null):void {			XML.ignoreWhitespace = false;			gameXML = new XML (resource);//			SETUP LAYOUT (GRID)			addChild (Puzzle);			var gridArray:Array = gameXML.grid.toString ().split ('');			gridLength = gridArray.length;			numColumns = Math.floor (Math.sqrt (gridArray.length));			Layout = new Distribution;			Puzzle.addChild (Layout);//			CREATE LAYOUT OF LETTER CLIPS			for (var letter:int in gridArray) {				NewSquare = new XwdLtrClip;				if (gridArray[letter] == ' ') {					NewSquare.visible = false;				} else {					NewSquare.letter = gridArray [letter].toUpperCase ();					NewSquare.xwdLtr.restrict = 'A-Z';					NewSquare.downWord = NewSquare.acrossWord = null;					Squares [letter] = NewSquare;				}				Layout.addChild (MovieClip (NewSquare));			}			Layout.size = numColumns * Layout.getChildAt (0).width;			Layout.position ();			Center.it (Layout, PuzRect, -1);//			CYCLE THROUGH WORD LIST, ADD CLUES TO LAYOUT, ADD MARKERS TO ENTRY XML			var CurrentSquares:Array = SquaresAcross;			ClueTextField.htmlText = '<p><u>ACROSS</u></p>';			var nextSquare:int;			var dir:Boolean;			across = true;			for (var entryNum:int in gameXML.entry) {				var entry:XML = gameXML.entry [entryNum];//				DIRECTION FLAG--ACROSS OR DOWN				dir = (entry.@length == (entry.@end - entry.@start + 1));//				IF DIRECTION CHANGES SWITCH FLAGS				if (dir != across) {					across = dir;					CurrentSquares = SquaresDown;					ClueTextField.htmlText += '<p><u>DOWN</u></p>';				}//				OFFSET FOR ENTRY TO CALCULATE LETTER ARRAY POSITION				entry.@offset = (across) ? 1:numColumns;//				INITIALIZE EACH SQUARE				for (i = 0; i < entry.@length; i++) {					nextSquare = int (entry.@start) + int (entry.@offset) * i;//					ADD XREF SO THAT THE CLUE CAN BE SELECTED WHEN THE LETTER CLIP IS SELECTED					(entry.@offset == 1) ? Squares [nextSquare].acrossWord = entry:Squares [nextSquare].downWord = entry;//					if (Squares [nextSquare].wordXref.indexOf (entry.@word) == -1) Squares[nextSquare].wordXref.push (entry);					CurrentSquares.push (Squares [nextSquare]);				}//				ADD LITTLE NUMBERS TO LETTER BOXES				var clueNum:int = int (entryNum) + 1;				if (Squares [entry.@start].xwdNbr.text == '') Squares[entry.@start].xwdNbr.text = clueNum;//				FILL IN WORD LIST WITH CLUES				entry.@clueStart = ClueTextField.text.length;				ClueTextField.htmlText += "<p><a href='event:" + entryNum + "'>" + clueNum + ". " + entry + '</a></p>';				entry.@clueEnd = ClueTextField.text.length - 1;			}			new ScrollBar (ClueTextField);			ClueTextField.addEventListener (TextEvent.LINK, hiliteWord, false, 0, true);			across = true;			DirArrow = addChild (new DirMarker);			DirArrow.scaleX = DirArrow.scaleY = Layout.scaleX;			DirArrow.mouseEnabled = DirArrow.mouseChildren = false;			DirArrow.visible = false;			Util.bringFront (DirArrow);		}		public function resetGame (option:Object = null):void {			for each (Square in Squares) {				TweenMax.killTweensOf (Square.Bg);				Square.Bg.transform.colorTransform = new ColorTransform ();				Square.xwdLtr.text = '';				// TESTING if (Squares.indexOf (Square)) Square.xwdLtr.text = Square.letter;				Square.filters = [];			}			stage.addEventListener (KeyboardEvent.KEY_DOWN, firstTime, false, 0, true);			selectSquare (Squares [gameXML.entry[0].@start]);			stopGame ();			startGame (true);		}		private function firstTime (e:KeyboardEvent):void {			e.target.removeEventListener (KeyboardEvent.KEY_DOWN, firstTime);			GameManager.instance.gameStarted ();		}		public function startGame (firstTime:Boolean = false):void {			DirArrow.visible = true;			toggleDirection (true);			Layout.addEventListener (MouseEvent.CLICK, selectSquare, false, 0, true);			stage.addEventListener (KeyboardEvent.KEY_DOWN, onKeyPress, false, 0, true);			stage.focus = stage;		}		public function stopGame (gameOver:Object = false):void {			DirArrow.visible = false;			Layout.removeEventListener (MouseEvent.CLICK, selectSquare);			stage.removeEventListener (KeyboardEvent.KEY_DOWN, onKeyPress);			if (gameOver) {				if (ActiveSquare) ActiveSquare.filters = [];				for each (Square in Squares) Util.cycleColor (Square.Bg);				GameManager.instance.gameFeedback ();			}		}		public function solveGame (success:Boolean = false):void {			if (ActiveSquare) ActiveSquare.filters = [];			for each (Square in Squares) Square.xwdLtr.text = Square.letter;			stopGame ();		}		public function cleanUp ():void {			stopGame ();			TweenMax.killAll ();		}		// ********* END IGame FUNCTIONS *********		// ********* START GAME FUNCTIONS *********		private function selectSquare (Square:Object):void {			if (ActiveSquare) ActiveSquare.filters = [];			ActiveSquare = (Square is MouseEvent) ? Square.target.parent:Square;			Center.it (DirArrow, ActiveSquare);			Layout.setChildIndex (ActiveSquare, Layout.numChildren - 2);			setSquareColors ();		}		private function hiliteWord (t:TextEvent):void {			var entry:XML = gameXML.entry [t.text];			if ((entry.@offset != 1) == across) toggleDirection ();			selectSquare (Squares [entry.@start]);		}		private function onKeyPress (e:KeyboardEvent):void {			switch (e.keyCode) {//			   SPECIAL FUNCTION KEYS				case (37) :					gotoSquare (-1);					break; // LEFT				case (38) :					gotoSquare (-numColumns);					break; // UP				case (39) :					gotoSquare (1);					break; // RIGHT				case (40) :					gotoSquare (numColumns);					break; // DOWN				case (8) :					gotoSquare (-1); // BACKSPACE				case (46) :					ActiveSquare.xwdLtr.text = '';					break; // DELETE				case (20) :					toggleDirection ();					break; // SHIFT				case (32) :					ActiveSquare.xwdLtr.text = '';					gotoSquare ();					break; // SPACEBAR				default://		         REJECT NON-LETTER KEYS (A=65, Z=90, a=97, z=122)					if ((e.charCode < 65) || ((e.charCode > 90) && (e.charCode < 97)) || (e.charCode > 122)) return;//			      LETTER KEY PRESSED, ADD LETTER					ActiveSquare.xwdLtr.text = String.fromCharCode (e.charCode).toUpperCase ();//		         CHECK IF ALL LETTERS CORRECT					getEmptySquaresIn ().length ? gotoSquare ():stopGame (true);			}//       RETURN IF NOT RIGHT LETTER//			if (ActiveSquare.letter != ActiveSquare.xwdLtr.text) return;		}		private function toggleDirection (firstTime:Boolean = false):void {			across = (firstTime) ? true:!across;			DirArrow.rotation = (!across) * 90;//			setSquareColors ();		}		private var clueTextRight:TextFormat = new TextFormat (null, null, 0x888888);		private var clueTextWrong:TextFormat = new TextFormat (null, null, 0x000000);		private var clueTextActive:TextFormat = new TextFormat (null, null, 0xEE0000);		private var clueTextHilite:int = 0xFFFF00;		private var squareRight:ColorTransform = new ColorTransform (.7, .7, .7, 1, 0, 0, 0, 0);		private var squareWrong:ColorTransform = new ColorTransform (1, 1, 1, 1, 0, 0, 0, 0);		private var activeRight:ColorTransform = new ColorTransform (.9, .9, .5, 1, 0, 0, 0, 0);		private var activeWrong:ColorTransform = new ColorTransform (1, 1, .6, 1, 0, 0, 0, 0);		private function setSquareColors ():void {//			SET TEXT COLOR OF CLUES FOR FINISHED WORDS			// LOOP THROUGH ALL LETTERS TO SET FOUND			for each (entry in gameXML.entry) {				var allLettersMatch:Boolean = true;				// CYCLE THROUGH LETTERS IN WORD				for (i = int (entry.@start); i <= int (entry.@end); i += int (entry.@offset)) {					if (Squares [i].xwdLtr.text != Squares [i].letter) {						allLettersMatch = false;						break;					}				}				entry.@found = allLettersMatch;//if (allLettersMatch) trace (gameXML.toXMLString ());				var setFormat:TextFormat = (allLettersMatch) ? clueTextRight:clueTextWrong;				ClueTextField.setTextFormat (setFormat, entry.@clueStart, entry.@clueEnd);			}//			CHECK IF PUZZLE IS FINISHED			if (!gameXML.entry.(@found == false).length()) stopGame (true);//			SET SQUARE BG IF LETTER CORRECT			for each (Square in Squares) {				Square.Bg.transform.colorTransform = (Square.letter == Square.xwdLtr.text) ? squareRight:squareWrong;			}//			FIND ACTIVE WORD BY DIRECTION			if ((across && (!ActiveSquare.acrossWord)) || ((!across) && (!ActiveSquare.downWord))) toggleDirection ();			var wordEntry:XML = (across) ? ActiveSquare.acrossWord:ActiveSquare.downWord;			hiliteActiveClue (wordEntry.@clueStart, wordEntry.@clueEnd);//			HILITE ACTIVE WORD			for (i = 0; i < wordEntry.@length; i++) {				Square = Squares [int (wordEntry.@start) + int (wordEntry.@offset) * i];				Square.Bg.transform.colorTransform = (Square.letter == Square.xwdLtr.text) ? activeRight:activeWrong;			}		}		private function hiliteActiveClue (clueStart:int, clueEnd:int):void {			ClueTextField.setTextFormat (clueTextActive, clueStart, clueEnd);			if (HiliteRect) {				HiliteRect.parent.removeChild (HiliteRect);				HiliteRect = null;			}			HiliteRect = ClueTextField.parent.addChildAt (new Sprite, ClueTextField.parent.getChildIndex (ClueTextField));			HiliteRect.x = ClueTextField.x;			HiliteRect.y = ClueTextField.y;			var topLeftRect:Rectangle = ClueTextField.getCharBoundaries (clueStart);			var botRightRect:Rectangle = ClueTextField.getCharBoundaries (clueEnd - 1);			HiliteRect.graphics.beginFill (clueTextHilite, .7);			HiliteRect.graphics.drawRoundRect (topLeftRect.x - 2, topLeftRect.y - 25, ClueTextField.width, botRightRect.y + botRightRect.height + 2 - topLeftRect.y, 8, 8);//			HiliteRect.graphics.drawRoundRect (topLeftRect.x - 2, topLeftRect.y, ClueTextField.width, botRightRect.y + botRightRect.height + 2 - topLeftRect.y, 8, 8);			HiliteRect.graphics.endFill ();		}		private function getEmptySquaresIn (SquareSet:Array = null):Array {			if (!SquareSet) SquareSet = Squares;			var EmptySet:Array = [];			for each (Square in SquareSet) if (Square.letter != Square.xwdLtr.text) EmptySet.push (Square);			return EmptySet;		}//		CALCULATE WHICH LETTER TO ACTIVATE NEXT		private function gotoSquare (dir:int = 0):void {//			ARROW KEY PRESSED, GO TO NEXT LETTER SQUARE IN THAT DIRECTION			var CurrentSquare:int = Squares.indexOf (ActiveSquare);			if (dir) {				do {					CurrentSquare = (CurrentSquare + dir) % gridLength;					if (CurrentSquare < 0) CurrentSquare += gridLength;//					trace (CurrentSquare);				} while (! Squares [CurrentSquare]);				selectSquare (Squares [CurrentSquare]);				return;			}//			GO TO NEXT (WRONG) SQUARE IN ACTIVE SET			var ActiveSet:Array = (across) ? SquaresAcross:SquaresDown;			var ActiveLoc:int = ActiveSet.indexOf (ActiveSquare);			if (ActiveLoc != -1) {				while (ActiveLoc < (ActiveSet.length - 1)) {					++ActiveLoc;					if (ActiveSet [ActiveLoc].letter != ActiveSet [ActiveLoc].xwdLtr.text) {						selectSquare (ActiveSet [ActiveLoc]);						return;					}				}			}//		   GO TO FIRST EMPTY SQUARE IN ACTIVE SET			var TestSet:Array = getEmptySquaresIn (ActiveSet);			if (TestSet.length) {				selectSquare (TestSet [0]);//			   ACTIVE SET FULL/OK, TOGGLE ACTIVE SET			} else {				toggleDirection ();				gotoSquare ();			}		}		public function get Printable ():MovieClip {			return Puzzle;		}	}}