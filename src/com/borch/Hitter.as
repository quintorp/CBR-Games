package com.borch {	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.events.Event;	import flash.filters.GlowFilter;	import flash.geom.ColorTransform;	public class Hitter extends MovieClip {		private var _smacks:Boolean;		private var _hitValue:int;		private var _speedX:int;		private var _speedY:int;		private var _class:Class;		private var _info:String;		public function Hitter (p_class:Class, TargetArea:DisplayObject, rank:int = 0):void {			super ();			_class = p_class;			addChild (new _class);			if (_class != PaulGood) scaleX = scaleY = .8 + Math.random () * .4;			_speedX = int (_speedY = 0);			switch (_class) {				case IslandClip :				case LogClip :					y = TargetArea.getBounds (TargetArea.stage).y + 25 + (TargetArea.height - 95) * Math.random ();					_speedX = int (5 + Math.random () * 2);					_hitValue = 100;					scaleX = scaleY *= .5 + y / TargetArea.stage.stageHeight;					break;				case TenComdClip :					y = rank * TargetArea.height / 13 + 200;					x = 100 + Math.random () * (TargetArea.width - 200);					_hitValue = 100;					break;				case ThingBad0 :				case ThingBad1 :				case ThingBad2 :					_smacks = true;					_hitValue = -100;				case PaulGood :					if (getChildAt (0).hasOwnProperty ('Toga')) {						getChildAt (0).Toga.transform.colorTransform = new ColorTransform (Math.random (), Math.random (), Math.random (), 1, 0, 0, 0, 0);					}				case ThingGood0 :				case ThingGood1 :				case ThingGood2 :					if (!_hitValue) _hitValue = 100;					y = 150 + Math.random () * (TargetArea.height - 250);					x = 600 + Math.random () * (TargetArea.width - 900);					scaleY *= .5 + y / TargetArea.stage.stageHeight;					scaleX = scaleY * Util.neg ();					break;				case NutClip:				case RockClip:					_hitValue = -50;					_smacks = true;				case MannaClip:					if (!_hitValue) _hitValue = 100;					getChildAt (0).turn = (5 + Math.random () * 10) * Util.neg ();					getChildAt (0).addEventListener (Event.ENTER_FRAME, rotateThing, false, 0, true);					x = Math.random () * (TargetArea.width - 100) + 100;					_speedY = 8 + Math.random () * 4;					break;				case FishClip :					_hitValue = 100;				case SharkClip :				case OctoClip :					if (!_hitValue) _hitValue = -100;					y = 180 + Math.random () * (TargetArea.stage.stageHeight - 200);					var direction:int = Util.neg ();					scaleX *= direction;					x = (direction + 1) ? 0 : TargetArea.stage.stageWidth;					_speedX = int ((6 + Math.random () * 3) * direction);					break;			}			var filterColor:int = (_hitValue < 0) ? 0xFF0000 : 0x88FF88;			filters = [new GlowFilter (filterColor, 1, 12, 12, 2, 2, false, false)];		}		private function rotateThing (e:Event):void {			e.target.rotation += e.target.turn;		}		public function get hitStatus ():Object {			var returnValue:Object = { hitValue : _hitValue, smacks : _smacks };			_smacks = false;			_hitValue = 0;			filters = [];			return returnValue;		}		public function get speedX ():int {			return _speedX;		}		public function get speedY ():int {			return _speedY;		}		public function get type ():Class {			return _class;		}		public function get info ():String {			return _info;		}		public function setInfo (label, feedback):void {			getChildAt (0).Label.text = label;			_info = "Remember the " + label + ":\n" + feedback;		}		public function setY (theY:Number):void {			y = theY;		}	}}