package com.borch {	import com.greensock.*;	import com.greensock.easing.Quad;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.filters.GlowFilter;	import flash.ui.Mouse;	public class BakeGame extends MovieClip implements IGame {		private var Ingredients:Array;		private var Measures:Array;		private var recipeNeeded:Array = [];		private var recipeAdded:Array = [];		private var SelectedMeasure:MovieClip;		private var Measure:MovieClip;		private var Ingredient:MovieClip;		public function BakeGame () {			super ();		}		public function initGame (resource:Object = null):void {			var recipe:String = String (resource);			recipeNeeded = { baklava : [1, 3, 1, 0, 1], cupcakes : [2, 3, 2, 1, 1], cookies : [1, 2, 1, 3, 2], unleavened : [3, 0, 1, 0, 2], prosfora : [3, 0, 2, 3, 2], vasilopita : [4, 1, 3, 3, 1] }[recipe];			Needed.text = recipeNeeded.join ('\n');			RecipeName.text = { baklava : "Baklava", cupcakes : "Cupcakes", cookies : "Cookies", unleavened : "Unleavened Bread", prosfora : "Prosfora", vasilopita : "Vasilopita" }[recipe];			Powder.measure = Salt.measure = Spoon;			Water.measure = Flour.measure = Sugar.measure = Cup;			Ingredients = [Flour, Sugar, Water, Powder, Salt];			Measures = [Cup, Spoon];			for each (Measure in Measures) {				Measure.startX = Measure.x;				Measure.startY = Measure.y;				Measure.stop ();			}			for each (Ingredient in Ingredients) Ingredient.Label.text = Ingredient.name;		}		public function resetGame (option:Object = null):void {			recipeAdded = [];			var i:int = recipeNeeded.length;			while (i--) recipeAdded.push (0);			Added.text = recipeAdded.toString ().replace (/,/g, '\n');			for each (Measure in Measures) Measure.addEventListener (MouseEvent.CLICK, firstTime, false, 0, true);			stopGame ();			startGame (true);		}		private function firstTime (e:MouseEvent):void {			for each (Measure in Measures) Measure.removeEventListener (MouseEvent.CLICK, firstTime);			GameManager.instance.gameStarted ();		}		public function startGame (firstTime:Boolean = false):void {			for each (Measure in Measures) {				Util.asButton (Measure);				Measure.addEventListener (MouseEvent.CLICK, onMeasureClick, false, 0, true);			}			for each (var Ingredient:MovieClip in Ingredients) {				Ingredient.addEventListener (MouseEvent.ROLL_OVER, setMouseFilter, false, 0, true);				Ingredient.addEventListener (MouseEvent.ROLL_OUT, setMouseFilter, false, 0, true);			}		}		public function stopGame (gameOver:Object = false):void {			Mouse.show ();			for each (Measure in Measures) {				Measure.removeEventListener (MouseEvent.CLICK, onMeasureClick);				Util.asButton (Measure, false);			}			for each (var Ingredient:MovieClip in Ingredients) {				Ingredient.removeEventListener (MouseEvent.ROLL_OVER, setMouseFilter);				Ingredient.removeEventListener (MouseEvent.ROLL_OUT, setMouseFilter);			}			Counter.removeEventListener (MouseEvent.CLICK, onCounterClick);			stage.removeEventListener (MouseEvent.MOUSE_MOVE, dragMeasure);			if (gameOver) GameManager.instance.gameFeedback ();		}		public function solveGame ():Boolean {			Mouse.show ();			var feedback:String = '';			var measures:Array = [" cups", " cups", " cups", " tsp", " tsp"];			for (var i:int in recipeNeeded) feedback += (recipeNeeded[i] != recipeAdded[i]) ? "It called for " + recipeNeeded[i] + measures[i] + " of " + Ingredients[i].name + ", but you added " + recipeAdded[i] + measures[i] + ". " : "";			if (feedback != "") {				feedback = "Are you sure you measured the ingredients correctly? It looks like you made a mistake. " + feedback + '\n\nAdd more ingredients, or click "RESET" to start over.';				var popupXML:XML = <popupXML></popupXML>;				popupXML.options = CBRXML.the().xml.buttonLabels.Continue.toString();				popupXML.body = feedback;				addChild (new GamePopup (popupXML));			} else {				Bowl.play ();				Cup.removeEventListener (MouseEvent.CLICK, onMeasureClick);				Spoon.removeEventListener (MouseEvent.CLICK, onMeasureClick);				stopGame (true);			}			return true;		}		public function cleanUp ():void {			Mouse.show ();			stopGame ();			TweenMax.killAll ();		}		// ********* END IGame FUNCTIONS *********		// ********* START GAME FUNCTIONS *********		private function setMouseFilter (m:MouseEvent):void {			var mouseFilters:Array = [				[],				[new GlowFilter (0xee9944, 1, 8, 8, 2)]			];			m.currentTarget.filters = mouseFilters [int (m.type == "rollOver")];		}		private function onMeasureClick (m:MouseEvent):void {			Mouse.hide ();			for each (Measure in Measures) {				Measure.removeEventListener (MouseEvent.CLICK, onMeasureClick);				Util.asButton (Measure, false);			}			SelectedMeasure = MovieClip (m.currentTarget);			Util.bringFront (SelectedMeasure);			SelectedMeasure.alpha = 1;			TweenMax.to (SelectedMeasure, 1, { scaleX : 1.2, scaleY : 1.2 });			SelectedMeasure.addEventListener (Event.ENTER_FRAME, checkMeasureFrameLabel, false, 0, true);			stage.addEventListener (MouseEvent.MOUSE_MOVE, dragMeasure, false, 0, true);			for each (var Ingredient:MovieClip in Ingredients) Ingredient.addEventListener (MouseEvent.CLICK, onIngredientClick, false, 0, true);			Counter.addEventListener (MouseEvent.CLICK, onCounterClick, false, 0, true);		}		private function onIngredientClick (m:MouseEvent):void {			TweenMax.killTweensOf (SelectedMeasure);			if (m.currentTarget.measure != SelectedMeasure) return;			stage.removeEventListener (MouseEvent.MOUSE_MOVE, dragMeasure);			SelectedMeasure.ingredient = m.currentTarget;			for each (var Ingredient:MovieClip in Ingredients) Ingredient.removeEventListener (MouseEvent.CLICK, onIngredientClick);			TweenMax.to (SelectedMeasure, .7, { x : SelectedMeasure.ingredient.x, y : SelectedMeasure.ingredient.y, easing : Quad.easeInOut, onComplete : dipMeasure });		}		private function dipMeasure ():void {			setChildIndex (SelectedMeasure, getChildIndex (SelectedMeasure.ingredient));			SelectedMeasure.play ();		}		// CALLED WHEN CORRESPONDING MEASURE FRAMELABEL IS HIT		public function moveToBowl ():void {			Util.bringFront (SelectedMeasure);			TweenMax.to (SelectedMeasure, .7, { x : Bowl.x, y : Bowl.y, onComplete : dumpMeasure, easing : Quad.easeInOut });		}		private function dumpMeasure ():void {			SelectedMeasure.play ();			++recipeAdded [Ingredients.indexOf (SelectedMeasure.ingredient)];			Added.text = recipeAdded.toString ().replace (/,/g, "\n")		}		// CALLED WHEN CORRESPONDING MEASURE FRAMELABEL IS HIT		public function growIngredients ():void {			Bowl.Ingredients.nextFrame ();		}		// CALLED WHEN CORRESPONDING MEASURE FRAMELABEL IS HIT		public function resetMeasure ():void {			for each (var Ingredient:MovieClip in Ingredients) Ingredient.addEventListener (MouseEvent.CLICK, onIngredientClick, false, 0, true);			SelectedMeasure.gotoAndStop (1);			stage.addEventListener (MouseEvent.MOUSE_MOVE, dragMeasure, false, 0, true);		}		// CLICK ON COUNTER		private function onCounterClick (event:MouseEvent):void {			Counter.removeEventListener (MouseEvent.CLICK, onCounterClick);			stage.removeEventListener (MouseEvent.MOUSE_MOVE, dragMeasure);			TweenMax.to (SelectedMeasure, 1, { scaleX : 1, scaleY : 1, x : SelectedMeasure.startX, y : SelectedMeasure.startY });			SelectedMeasure = null;			Mouse.show ();			for each (Measure in Measures) {				Util.asButton (Measure);				Measure.addEventListener (MouseEvent.CLICK, onMeasureClick, false, 0, true);			}			for each (var Ingredient:MovieClip in Ingredients) Ingredient.removeEventListener (MouseEvent.CLICK, onIngredientClick);		}		private function dragMeasure (m:MouseEvent):void {			SelectedMeasure.x = Util.inRange (mouseX, Bounds.x, Bounds.x + Bounds.width);			SelectedMeasure.y = Util.inRange (mouseY, Bounds.y, Bounds.y + Bounds.height);			m.updateAfterEvent ();		}		private function checkMeasureFrameLabel (event:Event):void {			if (event.currentTarget.currentLabel != null) this[event.currentTarget.currentLabel] ();		}	}}