package com.borch {	import com.greensock.TweenMax;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.events.AccelerometerEvent;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.geom.ColorTransform;	import flash.geom.Point;	import flash.sensors.Accelerometer;	public class NileGame extends MovieClip implements IGame {		private var moveDir:Array = [];		private const MOVE_AXIS:Object = { 37 : 0, 38 : 1, 39 : 0, 40 : 1 };		private const MOVE_DIRS:Object = { 37 : -15, 38 : -10, 39 : 10, 40 : 10 };		private const RIVER_COLOR:int = 0x00AABB;		private var curveWidth:int;		private var curveHeight:int;		private var xVar:int;		private var yVar:int;		private var riverSize:int;		private var riverSpeed:int;		private var landscapeOffset:Number;		private var RiverPoints:Array = [];		private var basketColor:ColorTransform;		private var Terrain:MovieClip;		private var Landscape:Array = [];		private var River:MovieClip;		private var Player:MosesClip;		private var accel:Accelerometer;		public function NileGame () {			super ();		}		public function initGame (resource:Object = null):void {			// ADD CLIPS			Terrain = new MovieClip;			addChild (Terrain);			River = new MovieClip;			Terrain.addChild (River);			Terrain.y = Math.round (stage.stageHeight) / 2;			Player = DisplayObject (new MosesClip);			addChild (Player);			Center.it (Player, this);			if (Accelerometer.isSupported) {				accel = new Accelerometer ();				accel.setRequestedUpdateInterval (50);				accel.addEventListener (AccelerometerEvent.UPDATE, setAccel, false, 0, true);			}		}		public function resetGame (option:Object = null):void {			// RESET GAME TO INITIAL POINT			moveDir = [0, 0];			curveWidth = 500;			curveHeight = 120;			xVar = 50;			yVar = 50;			riverSize = 250;			riverSpeed = 10;			landscapeOffset = 10;			Player.hits = Player.warn = 0;			Player.Eyes.gotoAndStop (Player.warn);			Player.x = stage.stageWidth / 4;			Player.y = stage.stageHeight / 2;			RiverPoints = initRiverArray ();			for each (var Thing:MovieClip in Landscape) Destroy.it (Thing);			for each (var Pt:Point in RiverPoints) Landscape.push (addToLandscapeAt (Pt));			basketColor = new ColorTransform ();			Player.transform.colorTransform = basketColor;			drawRiver ();			stopGame ();			TweenMax.delayedCall (2, startGame, [true]);		}		public function startGame (firstTime:Boolean = false):void {			if (!accel) {				stage.addEventListener (KeyboardEvent.KEY_DOWN, keyEvent, false, 0, true);				stage.addEventListener (KeyboardEvent.KEY_UP, keyEvent, false, 0, true);				stage.focus = stage;			}			addEventListener (Event.ENTER_FRAME, updateGame, false, 0, true);			if (firstTime) GameManager.instance.gameStarted ();		}		public function stopGame (gameOver:Object = false):void {			if (!accel) {				stage.removeEventListener (KeyboardEvent.KEY_DOWN, keyEvent);				stage.removeEventListener (KeyboardEvent.KEY_UP, keyEvent);			}			removeEventListener (Event.ENTER_FRAME, updateGame);			if (gameOver) GameManager.instance.gameFeedback ();		}		public function cleanUp ():void {			accel = null;			stopGame ();			TweenMax.killAll ();		}		// ********* END IGame FUNCTIONS *********		// ********* START GAME FUNCTIONS *********		private function setAccel (a:AccelerometerEvent):void {			moveDir[0] = -a.accelerationX * 15;			moveDir[1] = a.accelerationY * 15;		}		// HANDLE KEYBOARD EVENT FOR PLAYER MOVEMENT		private function keyEvent (event:KeyboardEvent):void {			if (!MOVE_DIRS [event.keyCode]) return;			moveDir[MOVE_AXIS[event.keyCode]] = (event.type == 'keyDown') ? MOVE_DIRS[event.keyCode] : 0;		}		private function updateGame (event:Event):void {			// MOVE PLAYER BASED ON ARROW KEYS WITHIN BOUNDS			Player.x = Util.inRange (Player.x + moveDir[0], 100, stage.stageWidth - 100);			Player.y = Util.inRange (Player.y + moveDir[1], 100, stage.stageHeight - 100);			// ROTATE PLAYER TOWARDS MOVEMENT, DRIFT BACK IF STRAIGHT			Player.rotation = (moveDir[1]) ? Util.inRange (Player.rotation + moveDir[1], -45, 45) : Player.rotation * .8;			// UPDATE PLAYER HITS, REMOVE POINTS TO 0 SLOWLY IF WITHIN RIVER			if (!River.hitTestPoint (Player.x, Player.y - 25, true)) {				Player.hits += 10;				Player.y += 15;			} else if (!River.hitTestPoint (Player.x, Player.y + 25, true)) {				Player.hits += 10;				Player.y -= 15;			} else {				Player.hits = Math.max (Player.hits - 1, 0);			}			// PULSING GLOW SHOWS DANGER IF MORE HITS			if (Player.warn != Math.round (Player.hits / 20)) {				Player.warn = Math.round (Player.hits / 20)				Player.Eyes.gotoAndStop (Player.warn);				basketColor.redOffset = 255 * Player.warn / 6;				//basketColor.greenMultiplier = (6 - Player.warn)/6;				//basketColor.blueMultiplier = (6 - Player.warn)/6;				Player.transform.colorTransform = basketColor;				if (Player.warn >= 6) stopGame (true);			}			Terrain.x -= riverSpeed;			if (Terrain.x <= -RiverPoints[2].x) {				RiverPoints.shift ();				for each (var Pt:Point in RiverPoints) Pt.x += Terrain.x;				RiverPoints.push (new Point (6 * curveWidth + randOff (xVar), curveHeight + randOff (yVar)));				if (RiverPoints [RiverPoints.length - 2].y > 0) RiverPoints [RiverPoints.length - 1].y *= -1;				Destroy.it (Landscape.shift ());				for each (var Thing:MovieClip in Landscape) Thing.x += Terrain.x;				Landscape.push (addToLandscapeAt (RiverPoints [RiverPoints.length - 1]));				drawRiver ();			}		}		private function drawRiver ():void {			Terrain.x = 0;			curveWidth -= 4;			curveHeight += 2;			xVar = Math.min (xVar + 20, 400);			riverSpeed += .6;			riverSize -= Math.random() * 20 - 7;			River.graphics.clear ();			River.graphics.lineStyle (riverSize, RIVER_COLOR);			CubicBezier.curveThroughPoints (River.graphics, RiverPoints, .5, 0);		}		private static function randOff (offset:Number):int {			return Math.round (Util.neg () * Math.random () * offset);		}		private function initRiverArray ():Array {			var StartPoints:Array = new Array (new Point (-curveWidth + randOff (xVar), 0), new Point (0 + randOff (xVar), 0), new Point (1 * curveWidth + randOff (xVar), 0), new Point (2 * curveWidth + randOff (xVar), 50 + randOff (yVar)), new Point (3 * curveWidth + randOff (xVar), -50 + randOff (yVar)), new Point (4 * curveWidth + randOff (xVar), 100 + randOff (yVar)), new Point (5 * curveWidth + randOff (xVar), -100 + randOff (yVar)), new Point (6 * curveWidth + randOff (xVar), curveHeight + randOff (yVar)));			return StartPoints;		}		private function addToLandscapeAt (Pnt:Point):MovieClip {			var LandscapeClip:MovieClip = MovieClip (new [ Landscape0, Landscape1, Landscape2 ] [Util.randomize (3)]);			Terrain.addChild (LandscapeClip);			LandscapeClip.x = Pnt.x + randOff (landscapeOffset);			var yLoc:Number = riverSize / 2 + 30 + randOff (landscapeOffset);			yLoc *= (Pnt.y < 0) ? 1:-1;			yLoc += Pnt.y;			LandscapeClip.y = yLoc;			return LandscapeClip;		}	}}